{
  "name": "pipeworks",
  "version": "1.2.1",
  "description": "Modularize functionality into execution pipelines. Create pipes. Fit 'em together. Start the flow!",
  "main": "pipeworks.js",
  "scripts": {
    "test": "mocha -R spec"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/kevinswiber/pipeworks"
  },
  "keywords": [
    "execution",
    "pipe",
    "pipeline",
    "reduce",
    "aggregate"
  ],
  "author": {
    "name": "Kevin Swiber",
    "email": "kswiber@gmail.com"
  },
  "devDependencies": {
    "mocha": "~1.9.0"
  },
  "testling": {
    "browsers": [
      "ie/6..latest",
      "chrome/20..latest",
      "firefox/10..latest",
      "safari/latest",
      "opera/11.0..latest",
      "iphone/6",
      "ipad/6"
    ],
    "harness": "mocha",
    "files": "test/*.js"
  },
  "license": "MIT",
  "readme": "# pipeworks \n\nCreate pipes.  Fit 'em together.  Start the flow!\n\nWith *pipeworks*, you can:\n\n- Fit components into execution pipelines.\n- Siphon the flow into branches during execution.\n- Join multiple pipelines together.\n- Intercept errors during execution.\n\n[![Build Status](https://travis-ci.org/kevinswiber/pipeworks.png)](https://travis-ci.org/kevinswiber/pipeworks)\n\n<!-- Testling has not been working lately. :(\n[![browser support](http://ci.testling.com/kevinswiber/pipeworks.png)](http://ci.testling.com/kevinswiber/pipeworks)\n-->\n\n## Example\n\n```javascript\nvar pipeworks = require('pipeworks');\n\npipeworks()\n  .fit(function(context, next) {\n    next(context.replace(/hot dogs/, 'tofu rolls'));\n  })\n  .fit(function(context, next) {\n    next(context.replace(/o/g, '0')\n      .replace(/e/g, '3')\n      .replace(/a/g, '4')\n      .replace(/l/g, '1')\n      .replace(/!/, '!!11~!11!')\n      .toUpperCase());\n  })\n  .fit(function(context, next) {\n    console.log(context);\n    next(context);\n  })\n  .flow('i bet i could eat more hot dogs than anyone!');\n\n// Output:\n// I B3T I C0U1D 34T M0R3 T0FU R011S TH4N 4NY0N3!!11~!11!\n```\n\n## Install\n\n```bash\n$ npm install pipeworks\n```\n\n## Usage\n\n### initialize\n\nStart by initializing a pipeline.\n\n```javascript\nvar pipeworks = require('pipeworks');\n\nvar pipeline = pipeworks();\n```\n\n### pipes\n\nPipes are the modular component of pipeworks.  Fit pipes together to form a pipeline.\n\nThey have the following signature: `function([arguments], next)`.  Pipes can take any number of arguments you wish to pass.  However, it's common to use a single `context` variable as a record to pass state between steps in the execution pipeline.  The last parameter passed to a pipe is a reference to the next function in the pipeline.  Pipes should always end with a call to `next([arguments])`.\n\nSee below.\n\n```javascript\nvar pipe = function(context, next) {\n  context.scores = [25.0, 17.0, 14.7];\n  next(context);\n};\n```\n\n### pipeline.fit([options], pipe)\n\nAdd a pipe to the pipeline.\n\n`options.affinity` - Either `hoist` or `sink`. Adds to the pre and post queues, respectively. Ensures a pipe gets fitted before or after the main execution pipeline.\n\nThe effect of setting the pipeline affinity to `'hoist'`:\n\n```javascript\npipeworks()\n  .fit(function(context, next) {\n    console.log('Cal Naughton, Jr: Shake and bake!');\n    next(context);\n  })\n  .fit({ affinity: 'hoist' }, function(context, next) {\n    console.log('Ricky Bobby: If you ain\\'t first, you\\'re last!');\n    next(context);\n  })\n  .flow({});\n\n// Output:\n// Ricky Bobby: If you ain't first, you're last!\n// Cal Naughton, Jr: Shake and bake!\n```\n\n### pipeline.siphon([arguments], next)\n\nRedirect the flow to another pipeline.\n\n```javascript\nvar hijacker = pipeworks();\nvar main = pipeworks();\n\nhijacker\n  .fit(function(context, next) {\n    context.hijacked = true;\n    console.log('hijacked!');\n    next(context);\n  });\n\nmain\n  .fit(function(context, next) {\n    console.log('getting started');\n    next(context);\n  })\n  .fit(function(context, next) {\n    console.log('am i getting hijacked?');\n    hijacker.siphon(context, next);\n  })\n  .fit(function(context, next) {\n    console.log('done-zo');\n    next(context);\n  });\n\nmain.flow({});\n\n// Output: \n// getting started\n// am i getting hijacked?\n// hijacked!\n// done-zo\n```\n\n### pipeline.join(pipeline)\n\nLink pipelines together.\n\n```javascript\nvar first = pipeworks();\nvar second = pipeworks();\nvar third = pipeworks();\n\nfirst\n  .fit(function(context, next) {\n    console.log('alpha');\n    next(context);\n  })\n  .fit(function(context, next) {\n    console.log('atlanta');\n    next(context);\n  });\n\nsecond\n  .fit(function(context, next) {\n    console.log('beta');\n    next(context);\n  })\n  .fit(function(context, next) {\n    console.log('boise');\n    next(context);\n  });\n\nthird\n  .fit(function(context, next) {\n    console.log('gamma');\n    next(context);\n  })\n  .fit(function(context, next) {\n    console.log('georgetown');\n    next(context);\n  });\n\nfirst.join(second).join(third).flow({});\n\n// Output:\n// alpha\n// atlanta\n// beta\n// boise\n// gamma\n// georgetown\n```\n\n### pipeline.flow([arguments])\n\nSend something down the pipeline!  Any number of arguments can be sent, but often there's just a single `context` object.\n\n```javascript\npipeworks()\n  .fit(function(context, next) {\n    context.age = 30;\n    next(context);\n  })\n  .fit(function(context, next) {\n    console.log(context);\n    next(context);\n  })\n  .flow({ name: 'Kevin' });\n\n// Output:\n// { name: 'Kevin', age: 30 }\n```\n\n### pipeline.fault(callback)\n\nHandle errors during pipeline execution. Using `pipeline.fault` allows access to the current execution context when errors occur in \nthe pipeline.\n\n\n* `callback` -  has the signature `function([arguments], error, next)`\n  *  `[arguments]` - the list of arguments sent to the currently executing pipe\n  * `error` is what was thrown\n  * `next` is a reference to the following pipe in the pipeline.  The `next` argument, in most cases, should not be called.\n\nNote: It's advisable to exit the process after an uncaught exception.  Exceptions leave your application in an unknown state. \nThis method uses [domains](http://nodejs.org/api/domain.html) under the hood.\n\n```javascript\nvar breakfast = pipeworks()\n  .fit(function(context, next) {\n    process.nextTick(function() {\n      if (context.flavor !== 'cinnamon') {\n        throw new Error('These waffles are not *jazzy*!');\n      }\n    }); // simulate async I/O operation\n  })\n  .fit(function(context, next) {\n    console.log('Thanks for breakfast!'); // never reached\n  });\n\nbreakfast.fault(function(context, error) {\n  console.log('Flavor on error:', context.flavor);\n  console.log(error.stack);\n  process.exit(); // the safe play\n});\n\nbreakfast.flow({ flavor: 'plain' })\n```\n\nUsage Notes: Joined pipelines should be treated as new pipelines.  Use fault on the joined pipeline itself for reliability. It is possible to have different fault handlers for each pipeline when using siphon. \n\nEnjoy!\n\n## License\n\nMIT\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/kevinswiber/pipeworks/issues"
  },
  "homepage": "https://github.com/kevinswiber/pipeworks",
  "_id": "pipeworks@1.2.1",
  "_from": "pipeworks@"
}
